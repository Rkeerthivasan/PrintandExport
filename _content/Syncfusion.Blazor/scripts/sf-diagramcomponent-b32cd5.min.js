/******/ (function (modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if (installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
            /******/
        }
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
            /******/
        };
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
        /******/
    }
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function (exports, name, getter) {
/******/ 		if (!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
            /******/
        }
        /******/
    };
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function (exports) {
/******/ 		if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
            /******/
        }
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
        /******/
    };
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function (value, mode) {
/******/ 		if (mode & 1) value = __webpack_require__(value);
/******/ 		if (mode & 8) return value;
/******/ 		if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
        /******/
    };
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function (module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
        /******/
    };
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "_content/Syncfusion.Blazor/scripts/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./bundles/sf-diagramcomponent.js");
    /******/
})
/************************************************************************/
/******/({

/***/ "./bundles/sf-diagramcomponent.js":
/*!****************************************!*\
  !*** ./bundles/sf-diagramcomponent.js ***!
  \****************************************/
/*! no exports provided */
/*! all exports used */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

            "use strict";
            __webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_sf_diagramcomponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/sf-diagramcomponent.js */ "./modules/sf-diagramcomponent.js");
/* harmony import */ var _modules_sf_diagramcomponent_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_modules_sf_diagramcomponent_js__WEBPACK_IMPORTED_MODULE_0__);


            /***/
        }),

/***/ "./modules/sf-diagramcomponent.js":
/*!****************************************!*\
  !*** ./modules/sf-diagramcomponent.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function (module, exports) {

            function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

            window.sfBlazor = window.sfBlazor || {};

            window.sfBlazor.Diagram = function () {
                'use strict';
                /**
                 * Rect defines and processes rectangular regions
                 */

                var Rect = function () {
                    function Rect(x, y, width, height) {
                        /**
                         * Sets the x-coordinate of the starting point of a rectangular region
                         *
                         * @default 0
                         */
                        this.x = Number.MAX_VALUE;
                        /**
                         * Sets the y-coordinate of the starting point of a rectangular region
                         *
                         * @default 0
                         */

                        this.y = Number.MAX_VALUE;
                        /**
                         * Sets the width of a rectangular region
                         *
                         * @default 0
                         */

                        this.width = 0;
                        /**
                         * Sets the height of a rectangular region
                         *
                         * @default 0
                         */

                        this.height = 0;

                        if (x === undefined || y === undefined) {
                            x = y = Number.MAX_VALUE;
                            width = height = 0;
                        } else {
                            if (width === undefined) {
                                width = 0;
                            }

                            if (height === undefined) {
                                height = 0;
                            }
                        }

                        this.x = x;
                        this.y = y;
                        this.width = width;
                        this.height = height;
                    }
                    /**   @private  */


                    Rect.empty = new Rect(Number.MAX_VALUE, Number.MIN_VALUE, 0, 0);
                    return Rect;
                }();

                var Size = (function () {
                    function Size(width, height) {
                        this.width = width;
                        this.height = height;
                    }
                    Size.prototype.isEmpty = function () {
                        return this.height === 0 && this.width === 0;
                    };
                    Size.prototype.clone = function () {
                        return new Size(this.width, this.height);
                    };
                    return Size;
                }());
                /** @private */


                function applyStyleAgainstCsp(svg, attributes) {
                    var keys = attributes.split(';');

                    for (var i = 0; i < keys.length; i++) {
                        var attribute = keys[i].split(':');

                        if (attribute.length === 2) {
                            svg.style[attribute[0].trim()] = attribute[1].trim();
                        }
                    }
                }
                /** @private */


                function setAttributeHtml(element, attributes) {
                    var keys = Object.keys(attributes);

                    for (var i = 0; i < keys.length; i++) {
                        if (keys[i] !== 'style') {
                            element.setAttribute(keys[i], attributes[keys[i]]);
                        } else {
                            applyStyleAgainstCsp(element, attributes[keys[i]]);
                        }
                    }
                }
                /** @hidden */


                function parentsUntil(elem, selector, isID) {
                    var parent = elem;

                    while (parent) {
                        if (isID ? parent.id === selector : hasClass(parent, selector)) {
                            break;
                        }

                        parent = parent.parentNode;
                    }

                    return parent;
                }
                /** @hidden */


                function hasClass(element, className) {
                    var eClassName = _typeof(element.className) === 'object' ? element.className.animVal : element.className;
                    return (' ' + eClassName + ' ').indexOf(' ' + className + ' ') > -1 ? true : false;
                }
                /**
                 * Init Draggable
                 */


                var InitDraggable = function () {
                    function InitDraggable(parent, symbolPaletteInstance) {
                        var _this = this;

                        this.over = function (e) {
                            var previewElementValue = "clonedNode";
                            var symbolPaletteDragEnter = "SymbolPaletteDragEnter";
                            var previewElement = document.getElementById(previewElementValue);
                            var component;

                            for (var i = _this.symbolPaletteInstance.length - 1; i >= 0; i--) {
                                if (e.dragData.draggable.id === _this.symbolPaletteInstance[i].id) {
                                    component = _this.symbolPaletteInstance[i].componentInstance;
                                    break;
                                }
                            }

                            component.invokeMethodAsync(symbolPaletteDragEnter, e.target.id.split("_")[0]);

                            if (previewElement) {
                                sf.base.remove(previewElement);
                                var cloneNode = document.getElementsByClassName("e-cloneproperties e-draganddrop e-dragclone");
                                cloneNode[0].style.width = "1px";
                                cloneNode[0].style.height = "1px";
                            }
                        };

                        this.drop = function (e) {
                            var component;
                            var symbolPaletteDrop = "SymbolPaletteDrop";
                            var diagramClass = "e-diagram";

                            for (var i = _this.symbolPaletteInstance.length - 1; i >= 0; i--) {
                                if (e.dragData.draggable.id === _this.symbolPaletteInstance[i].id) {
                                    component = _this.symbolPaletteInstance[i].componentInstance;
                                    break;
                                }
                            }

                            var ParentElement = parentsUntil(e.target, diagramClass);
                            component.invokeMethodAsync(symbolPaletteDrop, ParentElement.id);
                            sf.base.remove(e.droppedElement);
                        };

                        this.out = function (e) {
                            var component;
                            var symbolPaletteDragLeave = "SymbolPaletteDragLeave";

                            for (var i = _this.symbolPaletteInstance.length - 1; i >= 0; i--) {
                                if (e.target.children[0].id === _this.symbolPaletteInstance[i].id || e.target.parentNode.parentNode.parentElement.id === _this.symbolPaletteInstance[i].id) {
                                    component = _this.symbolPaletteInstance[i].componentInstance;
                                    break;
                                }
                            }

                            if (component) {
                                component.invokeMethodAsync(symbolPaletteDragLeave);
                            }
                        };

                        this.helper = function (e) {
                            var previewID = "previewID";
                            var accordianControl = "e-control e-accordion";
                            var helperElement = "helperElement";
                            var PaletteControl = document.getElementsByClassName(accordianControl)[0];
                            var visualElement = sf.base.createElement('div', {
                                className: 'e-cloneproperties e-draganddrop e-dragclone',
                                styles: 'color:"transparent" height:"auto",  width:' + PaletteControl.offsetWidth
                            });
                            var previewElement = document.getElementById(previewID);

                            if (previewElement === null) {
                                previewElement = e.sender.target;
                            }

                            if (previewElement) {
                                visualElement.setAttribute("id", helperElement);
                                document.body.appendChild(visualElement);
                                return visualElement;
                            }

                            return null;
                        };

                        this.dragStart = function (e) {
                            e.bindEvents(e.dragElement);
                        };

                        this.drag = function (e) {
                            var diagramClass = "e-diagram";

                            if (!parentsUntil(e.target, diagramClass)) {
                                var helperElement = "helperElement";
                                var previewID = "previewID";
                                var previewElement = document.getElementById(previewID);
                                var canAllowDrag = void 0;

                                for (var i = _this.symbolPaletteInstance.length - 1; i >= 0; i--) {
                                    if (e.element.id === _this.symbolPaletteInstance[i].id) {
                                        canAllowDrag = _this.symbolPaletteInstance[i].allowDrag;
                                        break;
                                    }
                                }

                                if (previewElement) {
                                    previewElement.style.visibility = "";
                                    var cloneNode = previewElement.cloneNode(true);
                                    cloneNode.style.display = "Block";
                                    cloneNode.style.visibility = true;
                                    cloneNode.setAttribute("class", "e-cloneproperties e-draganddrop e-dragclone");
                                    cloneNode.setAttribute("id", "clonedNode");
                                    var dragHelperElement = document.getElementById(helperElement);

                                    if (dragHelperElement && dragHelperElement.children[0]) {
                                        dragHelperElement.removeChild(dragHelperElement.children[0]);
                                    }

                                    if (!canAllowDrag) {
                                        dragHelperElement.style.opacity = "0";
                                    }

                                    dragHelperElement.appendChild(cloneNode);
                                }
                            }
                        };

                        this.dragStop = function (e) {
                            var diagramClass = "e-diagram";
                            var helperNode = document.getElementsByClassName("e-cloneproperties e-draganddrop e-dragclone");

                            if (helperNode.length > 0) {
                                helperNode[0].style.width = "1px";
                                helperNode[0].style.height = "1px";
                            }

                            if (helperNode.length > 1) {
                                for (var k = helperNode.length - 1; k > 0; k--) {
                                    if (helperNode[k].id == "helperElement") helperNode[k].remove();
                                }
                            }

                            if (!parentsUntil(e.target, diagramClass)) {
                                var helperElements = "helperElement";
                                var helperElement = document.getElementById(helperElements);
                                if (helperElement) helperElement.remove();
                                var component = void 0;
                                var elementDropToOutSideDiagram = "ElementDropToOutSideDiagram";

                                for (var i = _this.symbolPaletteInstance.length - 1; i >= 0; i--) {
                                    if (e.element.id === _this.symbolPaletteInstance[i].id) {
                                        component = _this.symbolPaletteInstance[i].componentInstance;
                                        break;
                                    }
                                }

                                if (component) {
                                    component.invokeMethodAsync(elementDropToOutSideDiagram);
                                }
                            }
                        };

                        this.symbolPaletteInstance = symbolPaletteInstance;

                        if (parent) {
                            this.initializeDrag(parent);
                        }
                    }
                    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
                        return new (P || (P = Promise))(function (resolve, reject) {
                            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
                            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
                            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
                            step((generator = generator.apply(thisArg, _arguments || [])).next());
                        });
                    };
                    var __generator = (this && this.__generator) || function (thisArg, body) {
                        var _ = { label: 0, sent: function () { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
                        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
                        function verb(n) { return function (v) { return step([n, v]); }; }
                        function step(op) {
                            if (f) throw new TypeError("Generator is already executing.");
                            while (_) try {
                                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                                if (y = 0, t) op = [op[0] & 2, t.value];
                                switch (op[0]) {
                                    case 0: case 1: t = op; break;
                                    case 4: _.label++; return { value: op[1], done: false };
                                    case 5: _.label++; y = op[1]; op = [0]; continue;
                                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                                    default:
                                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                                        if (t[2]) _.ops.pop();
                                        _.trys.pop(); continue;
                                }
                                op = body.call(thisArg, _);
                            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
                            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
                        }
                    };
                    InitDraggable.prototype.initializeDrag = function (parent) {
                        var element = parent.children[0];
                        this.draggable = new sf.base.Draggable(element, {
                            dragTarget: '.e-symbol-draggable',
                            helper: this.helper,
                            dragStart: this.dragStart,
                            drag: this.drag,
                            dragStop: this.dragStop,
                            preventDefault: false
                        });
                        var droppableElements = document.getElementsByClassName("e-control e-diagram e-lib e-droppable e-tooltip");

                        for (var i_1 = 0; i_1 < droppableElements.length; i_1++) {
                            this.droppable = new sf.base.Droppable(droppableElements[i_1], {
                                accept: '.e-dragclone',
                                drop: this.drop,
                                over: this.over,
                                out: this.out
                            });
                        }

                        var headerContent = document.getElementsByClassName("e-acrdn-header-content");

                        for (var i = 0; i < headerContent.length; i++) {
                            headerContent[i].style.textDecoration = "inherit";
                        }
                    };
                    /**
                     * To destroy the drag
                     * @return {void}
                     * @hidden
                     */


                    InitDraggable.prototype.destroy = function () {
                        this.draggable.destroy();
                    };

                    return InitDraggable;
                }();

                var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
                    return new (P || (P = Promise))(function (resolve, reject) {
                        function fulfilled(value) {
                            try {
                                step(generator.next(value));
                            } catch (e) {
                                reject(e);
                            }
                        }

                        function rejected(value) {
                            try {
                                step(generator["throw"](value));
                            } catch (e) {
                                reject(e);
                            }
                        }

                        function step(result) {
                            result.done ? resolve(result.value) : new P(function (resolve) {
                                resolve(result.value);
                            }).then(fulfilled, rejected);
                        }

                        step((generator = generator.apply(thisArg, _arguments || [])).next());
                    });
                };

                var __generator = undefined && undefined.__generator || function (thisArg, body) {
                    var _ = {
                        label: 0,
                        sent: function sent() {
                            if (t[0] & 1) throw t[1];
                            return t[1];
                        },
                        trys: [],
                        ops: []
                    },
                        f,
                        y,
                        t,
                        g;
                    return g = {
                        next: verb(0),
                        "throw": verb(1),
                        "return": verb(2)
                    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                        return this;
                    }), g;

                    function verb(n) {
                        return function (v) {
                            return step([n, v]);
                        };
                    }

                    function step(op) {
                        if (f) throw new TypeError("Generator is already executing.");

                        while (_) {
                            try {
                                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                                if (y = 0, t) op = [op[0] & 2, t.value];

                                switch (op[0]) {
                                    case 0:
                                    case 1:
                                        t = op;
                                        break;

                                    case 4:
                                        _.label++;
                                        return {
                                            value: op[1],
                                            done: false
                                        };

                                    case 5:
                                        _.label++;
                                        y = op[1];
                                        op = [0];
                                        continue;

                                    case 7:
                                        op = _.ops.pop();

                                        _.trys.pop();

                                        continue;

                                    default:
                                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                            _ = 0;
                                            continue;
                                        }

                                        if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                            _.label = op[1];
                                            break;
                                        }

                                        if (op[0] === 6 && _.label < t[1]) {
                                            _.label = t[1];
                                            t = op;
                                            break;
                                        }

                                        if (t && _.label < t[2]) {
                                            _.label = t[2];

                                            _.ops.push(op);

                                            break;
                                        }

                                        if (t[2]) _.ops.pop();

                                        _.trys.pop();

                                        continue;
                                }

                                op = body.call(thisArg, _);
                            } catch (e) {
                                op = [6, e];
                                y = 0;
                            } finally {
                                f = t = 0;
                            }
                        }

                        if (op[0] & 5) throw op[1];
                        return {
                            value: op[0] ? op[1] : void 0,
                            done: true
                        };
                    }
                };

                var eventStarted = false;
                var inAction = false;
                var eventInvokeValue = 0;
                var isMouseWheel = false;
                var isZoomPan = false;
                var Diagram = null;
                var scrollDiagramID = "";
                var defaultTextStyle = {
                    bold: false,
                    italic: false,
                    fontFamily: 'Arial',
                    color: 'black',
                    textAlign: "Center",
                    fontSize: 12.0,
                    textDecoration: "None",
                    textOverflow: "Wrap",
                    textWrapping: "WrapWithOverflow",
                    whiteSpace: "CollapseSpace"
                };
                var diagram = {
                    createHtmlElement: function z(elementType, attribute) {
                        var element = sf.base.createElement(elementType);

                        if (attribute) {
                            this.setAttribute(element, attribute);
                        }

                        return element;
                    },
                    setAttribute: function setAttribute(element, attributes) {
                        var keys = Object.keys(attributes);

                        for (var i = 0; i < keys.length; i++) {
                            element.setAttribute(keys[i], attributes[keys[i]]);
                        }
                    },
                    createMeasureElements: function createMeasureElements(isZoomValue, layerList, width, height, elementId, component) {
                        this.updateZoomPanTool(isZoomValue);
                        this.updateInnerLayerSize(layerList, width, height);

                        if (elementId && component) {
                            this.onAddWireEvents(elementId, component);
                        }

                        var measureWindowElement = 'measureElement';

                        if (!window[measureWindowElement]) {
                            var divElement = this.createHtmlElement('div', {
                                id: 'measureElement',
                                style: 'visibility:hidden ; height: 0px ; width: 0px; overflow: hidden;'
                            });
                            var text = this.createHtmlElement('span', {
                                'style': 'display:inline-block ; line-height: normal'
                            });
                            divElement.appendChild(text);
                            var imageElement = void 0;
                            imageElement = this.createHtmlElement('img', {});
                            divElement.appendChild(imageElement);
                            var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                            svg.setAttribute('xlink', 'http://www.w3.org/1999/xlink');
                            divElement.appendChild(svg);
                            var element = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                            svg.appendChild(element);
                            var tSpan = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
                            svg.appendChild(tSpan);
                            window[measureWindowElement] = divElement;
                            window[measureWindowElement].usageCount = 1;
                            document.body.appendChild(divElement);
                            var measureElementCount = 'measureElementCount';

                            if (!window[measureElementCount]) {
                                window[measureElementCount] = 1;
                            } else {
                                window[measureElementCount]++;
                            }
                        } else {
                            window[measureWindowElement].usageCount += 1;
                        }
                    },
                    updateZoomPanTool: function updateZoomPanTool(val) {
                        isZoomPan = val;
                    },
                    updateInnerLayerSize: function updateInnerLayerSize(layerList, width, height, left, top, eventValue) {
                        if (layerList != undefined && width != undefined && height != undefined && layerList.length > 0) {
                            var layer = void 0;

                            for (var i = 0; i < layerList.length - 1; i++) {
                                layer = document.getElementById(layerList[i]);

                                if (layer) {
                                    layer.style.width = width;
                                    layer.style.height = height;
                                }
                            }
                        }

                        if (isMouseWheel) {
                            isMouseWheel = false;
                        }

                        if (layerList != undefined && layerList.length > 0) {
                            var element = document.getElementById(layerList[layerList.length - 1]);
                            return this.onChangeScrollValues(element, left, top, eventValue);
                        }

                        return null;
                    },
                    onChangeScrollValues: function onChangeScrollValues(element, left, top, eventValue) {
                        if (element && left && top) {
                            if (eventInvokeValue == eventValue) {
                                eventStarted = false;
                            }

                            element.scrollLeft = left;
                            element.scrollTop = top;
                            return this.measureScrollValues(scrollDiagramID);
                        }

                        return null;
                    },
                    measureScrollValues: function measureScrollValues(diagramId) {
                        var element = document.getElementById(diagramId);
                        var point = new Rect(element.scrollLeft, element.scrollTop, element.scrollWidth, element.scrollHeight);
                        return point;
                    },
                    measurePath: function measurePath(data) {
                        if (data) {
                            var measureWindowElement = 'measureElement';
                            window[measureWindowElement].style.visibility = 'visible';
                            var svg = window[measureWindowElement].children[2];
                            var element = this.getChildNode(svg)[0];
                            element.setAttribute('d', data);
                            var bounds = element.getBBox();
                            var svgBounds = new Rect(bounds.x, bounds.y, bounds.width, bounds.height);
                            window[measureWindowElement].style.visibility = 'hidden';
                            return svgBounds;
                        }

                        return new Rect(0, 0, 0, 0);
                    },
                    openUrl: function openUrl(url) {
                        return __awaiter(this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                window.open(url, '_blank');
                                return [2
                                    /*return*/
                                ];
                            });
                        });
                    },
                    textEdit: function textEdit(annotation, centerPoint, nodeBounds, transform, canZoomTextEdit, annottaionId) {
                        var _this = this;

                        var textBoxDiv = "diagram_editTextBoxDiv";
                        var editBoxDiv = "diagram_editBox";
                        var textEditing = document.getElementById(textBoxDiv);
                        var x;
                        var y;
                        annotation.id = annottaionId;
                        var attributes;
                        var textArea = document.getElementById(editBoxDiv);
                        var text = annotation.content;

                        if (!textEditing && !textArea) {
                            textEditing = this.createHtmlElement('div', {});
                            textArea = this.createHtmlElement('textarea', {});
                            var diagramDiv = document.getElementsByClassName("e-control e-diagram e-lib e-droppable e-tooltip");
                            var diagramCanvas = diagramDiv[0].children[0];
                            diagramCanvas.appendChild(textEditing);
                            textEditing.appendChild(textArea);
                            textArea.appendChild(document.createTextNode(text));
                            this[textBoxDiv] = textEditing;
                            this[editBoxDiv] = textArea;
                        }

                        var minWidth = 90;
                        var maxWidth = annotation.bounds.width < nodeBounds.width ? annotation.bounds.width : nodeBounds.width;
                        maxWidth = minWidth > maxWidth ? minWidth : maxWidth;
                        var bounds = this.measureHtmlText(annotation.style, text, undefined, undefined, maxWidth);

                        if (bounds.width == 0 && bounds.height == 0) {
                            bounds.width = 50;
                            bounds.height = 12;
                        }

                        var scale = canZoomTextEdit ? transform.scale : 1;
                        bounds.width = Math.max(bounds.width, 50);
                        x = (centerPoint.x + transform.tx) * transform.scale - bounds.width / 2 * scale - 2.5;
                        y = (centerPoint.y + transform.ty) * transform.scale - bounds.height / 2 * scale - 3;
                        attributes = {
                            'id': 'diagram' + '_editTextBoxDiv',
                            'style': 'position: absolute' + ';left:' + x + 'px;top:' + y + 'px;width:' + (bounds.width + 1) * scale + 'px;height:' + bounds.height * scale + 'px; containerName:' + 'temp' + ';'
                        };
                        setAttributeHtml(textEditing, attributes);
                        var style = annotation.style;
                        attributes = {
                            'id': 'diagram' + '_editBox',
                            'style': 'width:' + (bounds.width + 1) * scale + 'px;height:' + bounds.height * scale + 'px;resize: none;outline: none;overflow: hidden;' + ';font-family:' + style.fontFamily + ';font-size:' + style.fontSize * scale + 'px;text-align:' + annotation.style.textAlign.toLocaleLowerCase() + ';',
                            'class': 'e-diagram-text-edit'
                        };
                        setAttributeHtml(textArea, attributes);
                        textArea.style.fontWeight = style.bold ? 'bold' : '';
                        textArea.style.fontStyle = style.italic ? 'italic' : '';
                        textArea.style.lineHeight = (style.fontSize * 1.2 + 'px;').toString();
                        var nodeTextbox = document.getElementById(annotation.id + "_text");

                        if (nodeTextbox) {
                            nodeTextbox.setAttribute("visibility", "hidden");
                        }

                        textArea.style.textDecoration = style.textDecoration ? style.textDecoration : '';
                        textArea.addEventListener('input', function (e) {
                            _this.inputChange(e, annotation, nodeBounds, centerPoint, transform, canZoomTextEdit);
                        });
                        textArea.select();
                        window['annotation'] = annotation;
                    },
                    inputChange: function inputChange(e, annotation, nodeBounds, centerPoint, transform, canZoomTextEdit) {
                        var minWidth = 90;
                        var textBoxDiv = "diagram_editTextBoxDiv";
                        var editBoxDiv = "diagram_editBox";
                        var maxWidth;
                        var minHeight = 12;
                        var fontsize;
                        var height;
                        var width;
                        var textBounds;
                        var editTextBox = this[editBoxDiv];
                        var editTextBoxDiv = this[textBoxDiv];
                        var text = editTextBox.value;
                        var line = text.split('\n');
                        maxWidth = nodeBounds.width < annotation.bounds.width ? nodeBounds.width : annotation.bounds.width;
                        maxWidth = maxWidth > minWidth ? maxWidth : minWidth;
                        textBounds = this.measureHtmlText(annotation.style, text, undefined, undefined, maxWidth);
                        fontsize = Number(editTextBox.style.fontSize.split('px')[0]);

                        if (line.length > 1 && line[line.length - 1] === '') {
                            textBounds.height = textBounds.height + fontsize;
                        }

                        var scale = canZoomTextEdit ? transform.scale : 1;
                        width = textBounds.width;
                        width = (minWidth > width ? minWidth : width) * scale;
                        height = (minHeight > textBounds.height ? minHeight : textBounds.height) * scale;
                        editTextBoxDiv.style.left = (centerPoint.x + transform.tx) * transform.scale - width / 2 - 2.5 + 'px';
                        editTextBoxDiv.style.top = (centerPoint.y + transform.ty) * transform.scale - height / 2 - 3 + 'px';
                        editTextBoxDiv.style.width = width + 'px';
                        editTextBoxDiv.style.height = height + 'px';
                        editTextBox.style.minHeight = minHeight + 'px';
                        editTextBox.style.minWidth = minWidth + 'px';
                        editTextBox.style.width = width + 'px';
                        editTextBox.style.height = height + 'px';
                    },
                    measureHtmlText: function measureHtmlText(style, content, width, height, maxWidth) {
                        var bounds = {};
                        var text = this.createHtmlElement('span', {
                            'style': 'display:inline-block; line-height: normal'
                        });

                        if (style.bold) {
                            text.style.fontWeight = 'bold';
                        }

                        if (style.italic) {
                            text.style.fontStyle = 'italic';
                        }

                        if (width !== undefined) {
                            text.style.width = width.toString() + 'px';
                        }

                        if (height !== undefined) {
                            text.style.height = height.toString() + 'px';
                        }

                        if (maxWidth !== undefined) {
                            text.style.maxWidth = maxWidth.toString() + 'px';
                        }

                        text.style.fontFamily = style.fontFamily;
                        text.style.fontSize = style.fontSize + 'px';
                        text.style.color = style.color;
                        text.textContent = content;
                        text.style.whiteSpace = this.whiteSpaceToString(style.whiteSpace, style.textWrapping);

                        if (maxWidth !== undefined) {
                            text.style.wordBreak = 'break-word';
                        } else {
                            text.style.wordBreak = this.wordBreakToString(style.textWrapping);
                        }

                        document.body.appendChild(text);
                        bounds.width = text.offsetWidth;
                        bounds.height = text.offsetHeight;
                        document.body.removeChild(text);
                        return bounds;
                    },
                    getChildNode: function getChildNode(node) {
                        var child;
                        var collection = [];

                        if (sf.base.Browser.info.name === 'msie' || sf.base.Browser.info.name === 'edge') {
                            for (var i = 0; i < node.childNodes.length; i++) {
                                child = node.childNodes[i];

                                if (child.nodeType === 1) {
                                    collection.push(child);
                                }
                            }
                        } else {
                            collection = node.children;
                        }

                        return collection;
                    },
                    measureBounds: function measureBounds(pathobj, textObj, imageObj, nativeObj) {
                        return __awaiter(this, void 0, void 0, function () {
                            var previousValue, accordianPanel, k, finalResult, pathResult, textResult, imageResult, nativeResult, measureWindowElement, result, svg, element, i, data, bounds, svgBounds, dom, bounds, result, i, data, content, style, size, nodeSz, images, value, result, result, results, nativeSize, i, nativeId, nativeBounds, svgBounds, k;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        if (nativeObj != null) {
                                            accordianPanel = document.getElementsByClassName("e-acrdn-panel e-content-hide");
                                            previousValue = [];

                                            for (k = 0; k < accordianPanel.length; k++) {
                                                previousValue[k] = accordianPanel[k].style.display;
                                                accordianPanel[k].style.display = "block";
                                            }
                                        }

                                        finalResult = {};
                                        pathResult = {};
                                        textResult = {};
                                        imageResult = {};
                                        nativeResult = {};
                                        measureWindowElement = 'measureElement';

                                        if (pathobj) {
                                            result = Object.keys(pathobj).map(function (key) {
                                                return [pathobj[key], key];
                                            });
                                            window[measureWindowElement].style.visibility = 'visible';
                                            svg = window[measureWindowElement].children[2];
                                            element = this.getChildNode(svg)[0];

                                            for (i = 0; i < result.length; i++) {
                                                if (result[i][0] == "Path") {
                                                    data = result[i][1];
                                                    element.setAttribute('d', data);
                                                    bounds = element.getBBox();
                                                    svgBounds = {
                                                        x: bounds.x,
                                                        y: bounds.y,
                                                        width: bounds.width,
                                                        height: bounds.height
                                                    };
                                                    pathResult[data] = svgBounds;
                                                } else if (result[i][0].indexOf("GetBoundingClientRect") != -1) {
                                                    dom = document.getElementById(result[i][1]);

                                                    if (dom) {
                                                        bounds = dom.getBoundingClientRect();
                                                        pathResult[result[i][0]] = {
                                                            x: bounds.x,
                                                            y: bounds.y,
                                                            width: bounds.width,
                                                            height: bounds.height
                                                        };
                                                    }

                                                    if (result[i][0] == "GetBoundingClientRect") {
                                                        scrollDiagramID = result[i][1];
                                                        pathResult["GetScrollerBounds"] = this.measureScrollValues(result[i][1]);
                                                    }
                                                }
                                            }
                                        }

                                        if (textObj) {
                                            result = Object.keys(textObj).map(function (key) {
                                                return [textObj[key], key];
                                            });

                                            for (i = 0; i < result.length; i++) {
                                                data = result[i][1];
                                                content = textObj[data].content;
                                                style = textObj[data].style;
                                                size = textObj[data].bounds;
                                                nodeSz = textObj[data].nodeSize;
                                                size.width = size.width == null ? undefined : size.width;
                                                size.height = size.height == null ? undefined : size.height;
                                                nodeSz.width = nodeSz.width == null ? undefined : nodeSz.width;
                                                nodeSz.height = nodeSz.height == null ? undefined : nodeSz.height;
                                                textResult[data] = this.measureText(size, style, content, size.width || nodeSz.width);
                                            }
                                        }

                                        if (!imageObj) return [3
                                            /*break*/
                                            , 2];
                                        images = Object.keys(imageObj).map(function (key) {
                                            return [imageObj[key], key];
                                        });
                                        if (!(images.length > 0)) return [3
                                            /*break*/
                                            , 2];
                                        value = 0;
                                        result = {};
                                        return [4
                                            /*yield*/
                                            , this.loadImage(images, value, result)];

                                    case 1:
                                        _a.sent();

                                        imageResult = result;
                                        _a.label = 2;

                                    case 2:
                                        if (nativeObj) {
                                            result = Object.keys(nativeObj).map(function (key) {
                                                return [nativeObj[key], key];
                                            });

                                            if (result.length > 0) {
                                                results = {};
                                                nativeSize = {};

                                                for (i = 0; i < result.length; i++) {
                                                    nativeId = result[i][0];
                                                    nativeBounds = document.getElementById(nativeId);
                                                    svgBounds = nativeBounds.getBoundingClientRect();
                                                    nativeSize = {
                                                        width: svgBounds.width,
                                                        height: svgBounds.height
                                                    };
                                                    results[result[i][1]] = nativeSize;
                                                }

                                                nativeResult = results;
                                            }
                                        }

                                        pathResult["GetScrollerWidth"] = this.getScrollerWidth();
                                        finalResult["Path"] = pathResult;
                                        finalResult["Text"] = textResult;
                                        finalResult["Image"] = imageResult;
                                        finalResult["Native"] = nativeResult;

                                        if (previousValue != null) {
                                            for (k = 0; k < accordianPanel.length; k++) {
                                                accordianPanel[k].style.display = previousValue[k].toString();
                                            }
                                        }

                                        window[measureWindowElement].style.visibility = 'hidden';
                                        return [2
                                            /*return*/
                                            , finalResult];
                                }
                            });
                        });
                    },
                    measureText: function measureText(size, style, content, maxWidth, textValue) {
                        var finalResult = {};
                        var bounds = {
                            width: 0,
                            height: 0
                        };
                        var childNodes;
                        var wrapBounds;
                        var options = this.getTextOptions(content, size, style, maxWidth);
                        childNodes = this.wrapSvgText(options, textValue, maxWidth);
                        wrapBounds = this.wrapSvgTextAlign(options, childNodes);
                        bounds.width = wrapBounds.width;

                        if (wrapBounds.width >= maxWidth && options.textOverflow !== 'Wrap') {
                            bounds.width = maxWidth;
                        }

                        bounds.height = childNodes.length * options.fontSize * 1.2;

                        if (wrapBounds.width > options.width && options.textOverflow !== 'Wrap' && options.textWrapping === 'NoWrap') {
                            childNodes[0].text = this.overFlow(options.content, options);
                        }

                        finalResult["Bounds"] = bounds;
                        finalResult["WrapBounds"] = wrapBounds;
                        finalResult["ChildNodes"] = childNodes;
                        return finalResult;
                    },
                    getTextOptions: function getTextOptions(content, size, style, maxWidth) {
                        var options = {
                            fill: style.fill,
                            stroke: style.strokeColor,
                            strokeWidth: style.strokeWidth,
                            dashArray: style.strokeDashArray,
                            opacity: style.opacity,
                            gradient: style.gradient,
                            width: maxWidth || size.width,
                            height: size.height
                        };
                        options.fontSize = style.fontSize || defaultTextStyle.fontSize;
                        options.fontFamily = style.fontFamily || defaultTextStyle.fontFamily;
                        options.textOverflow = style.textOverflow || defaultTextStyle.textOverflow;
                        options.textDecoration = style.textDecoration || defaultTextStyle.textDecoration;
                        options.doWrap = style.doWrap;
                        options.whiteSpace = this.whiteSpaceToString(style.whiteSpace || defaultTextStyle.whiteSpace, style.textWrapping || defaultTextStyle.textWrapping);
                        options.content = content;
                        options.textWrapping = style.textWrapping || defaultTextStyle.textWrapping;
                        options.breakWord = this.wordBreakToString(style.textWrapping || defaultTextStyle.textWrapping);
                        options.textAlign = this.textAlignToString(style.textAlign || defaultTextStyle.textAlign);
                        options.color = style.color || defaultTextStyle.color;
                        options.italic = style.italic || defaultTextStyle.italic;
                        options.bold = style.bold || defaultTextStyle.bold;
                        options.dashArray = '';
                        options.strokeWidth = 0;
                        options.fill = '';
                        return options;
                    },
                    whiteSpaceToString: function whiteSpaceToString(value, wrap) {
                        if (wrap === 'NoWrap' && value === 'PreserveAll') {
                            return 'pre';
                        }

                        var state = '';

                        switch (value) {
                            case 'CollapseAll':
                                state = 'nowrap';
                                break;

                            case 'CollapseSpace':
                                state = 'pre-line';
                                break;

                            case 'PreserveAll':
                                state = 'pre-wrap';
                                break;
                        }

                        return state;
                    },
                    wordBreakToString: function wordBreakToString(value) {
                        var state = '';

                        switch (value) {
                            case 'Wrap':
                                state = 'breakall';
                                break;

                            case 'NoWrap':
                                state = 'keepall';
                                break;

                            case 'WrapWithOverflow':
                                state = 'normal';
                                break;

                            case 'LineThrough':
                                state = 'line-through';
                                break;
                        }

                        return state;
                    },
                    textAlignToString: function textAlignToString(value) {
                        var state = '';

                        switch (value) {
                            case 'Center':
                                state = 'center';
                                break;

                            case 'Left':
                                state = 'left';
                                break;

                            case 'Right':
                                state = 'right';
                                break;
                        }

                        return state;
                    },
                    wrapSvgText: function wrapSvgText(text, textValue, laneWidth) {
                        var childNodes = [];
                        var k = 0;
                        var txtValue;
                        var bounds1;
                        var content = textValue || text.content;

                        if (text.whiteSpace !== 'nowrap' && text.whiteSpace !== 'pre') {
                            if (text.breakWord === 'breakall') {
                                txtValue = '';
                                txtValue += content[0];

                                for (k = 0; k < content.length; k++) {
                                    bounds1 = this.bBoxText(txtValue, text);

                                    if (bounds1 >= text.width && txtValue.length > 0) {
                                        childNodes[childNodes.length] = {
                                            text: txtValue,
                                            x: 0,
                                            dy: 0,
                                            width: bounds1
                                        };
                                        txtValue = '';
                                    } else {
                                        txtValue = txtValue + (content[k + 1] || '');

                                        if (txtValue.indexOf('\n') > -1) {
                                            childNodes[childNodes.length] = {
                                                text: txtValue,
                                                x: 0,
                                                dy: 0,
                                                width: this.bBoxText(txtValue, text)
                                            };
                                            txtValue = '';
                                        }

                                        var width = this.bBoxText(txtValue, text);

                                        if (Math.ceil(width) + 2 >= text.width && txtValue.length > 0) {
                                            childNodes[childNodes.length] = {
                                                text: txtValue,
                                                x: 0,
                                                dy: 0,
                                                width: width
                                            };
                                            txtValue = '';
                                        }

                                        if (k === content.length - 1 && txtValue.length > 0) {
                                            childNodes[childNodes.length] = {
                                                text: txtValue,
                                                x: 0,
                                                dy: 0,
                                                width: width
                                            };
                                            txtValue = '';
                                        }
                                    }
                                }
                            } else {
                                childNodes = this.wordWrapping(text, textValue, laneWidth);
                            }
                        } else {
                            childNodes[childNodes.length] = {
                                text: content,
                                x: 0,
                                dy: 0,
                                width: this.bBoxText(content, text)
                            };
                        }

                        return childNodes;
                    },
                    wordWrapping: function wordWrapping(text, textValue, laneWidth) {
                        var childNodes = [];
                        var txtValue = '';
                        var j = 0;
                        var i = 0;
                        var wrap = text.whiteSpace !== 'nowrap' ? true : false;
                        var content = textValue || text.content;
                        var eachLine = content.split('\n');
                        var words;
                        var newText;
                        var existingWidth;
                        var existingText;

                        for (j = 0; j < eachLine.length; j++) {
                            words = text.textWrapping !== 'NoWrap' ? eachLine[j].split(' ') : text.textWrapping === 'NoWrap' ? [eachLine[j]] : eachLine;

                            for (i = 0; i < words.length; i++) {
                                txtValue += ((i !== 0 || words.length === 1) && wrap && txtValue.length > 0 ? ' ' : '') + words[i];
                                newText = txtValue + ' ' + (words[i + 1] || '');
                                var width = this.bBoxText(newText, text);

                                if (Math.floor(width) > (laneWidth || text.width) - 2 && txtValue.length > 0) {
                                    childNodes[childNodes.length] = {
                                        text: txtValue,
                                        x: 0,
                                        dy: 0,
                                        width: newText === txtValue ? width : txtValue === existingText ? existingWidth : this.bBoxText(txtValue, text)
                                    };
                                    txtValue = '';
                                } else {
                                    if (i === words.length - 1) {
                                        childNodes[childNodes.length] = {
                                            text: txtValue,
                                            x: 0,
                                            dy: 0,
                                            width: width
                                        };
                                        txtValue = '';
                                    }
                                }

                                existingText = newText;
                                existingWidth = width;
                            }
                        }

                        return childNodes;
                    },
                    wrapSvgTextAlign: function wrapSvgTextAlign(text, childNodes) {
                        var wrapBounds = {
                            x: 0,
                            width: 0
                        };
                        var k = 0;
                        var txtWidth;
                        var width;

                        for (k = 0; k < childNodes.length; k++) {
                            txtWidth = childNodes[k].width;
                            width = txtWidth;

                            if (text.textAlign === 'left') {
                                txtWidth = 0;
                            } else if (text.textAlign === 'center') {
                                if (txtWidth > text.width && (text.textOverflow === 'Ellipsis' || text.textOverflow === 'Clip')) {
                                    txtWidth = 0;
                                } else {
                                    txtWidth = -txtWidth / 2;
                                }
                            } else if (text.textAlign === 'right') {
                                txtWidth = -txtWidth;
                            } else {
                                txtWidth = childNodes.length > 1 ? 0 : -txtWidth / 2;
                            }

                            childNodes[k].dy = text.fontSize * 1.2;
                            childNodes[k].x = txtWidth;

                            if (!wrapBounds) {
                                wrapBounds = {
                                    x: txtWidth,
                                    width: width
                                };
                            } else {
                                wrapBounds.x = Math.min(wrapBounds.x, txtWidth);
                                wrapBounds.width = Math.max(wrapBounds.width, width);
                            }
                        }

                        return wrapBounds;
                    },
                    overFlow: function overFlow(text, options) {
                        var i = 0;
                        var j = 0;
                        var middle = 0;
                        var bounds = 0;
                        var temp = '';
                        j = text.length;
                        var t = 0;

                        do {
                            if (bounds > 0) {
                                i = middle;
                            }

                            middle = Math.floor(this.middleElement(i, j));
                            temp += text.substr(i, middle);
                            bounds = this.bBoxText(temp, options);
                        } while (bounds <= options.width);

                        temp = temp.substr(0, i);

                        for (t = i; t < j; t++) {
                            temp += text[t];
                            bounds = this.bBoxText(temp, options);

                            if (bounds >= options.width) {
                                text = text.substr(0, temp.length - 1);
                                break;
                            }
                        }

                        if (options.textOverflow === 'Ellipsis') {
                            text = text.substr(0, text.length - 3);
                            text += '...';
                        } else {
                            text = text.substr(0, text.length);
                        }

                        return text;
                    },
                    middleElement: function middleElement(i, j) {
                        var m = 0;
                        m = (i + j) / 2;
                        return m;
                    },
                    getScrollerWidth: function getScrollerWidth() {
                        var outer = this.createHtmlElement('div', {
                            'style': 'visibility:hidden; width: 100px'
                        });
                        document.body.appendChild(outer);
                        var widthNoScroll = outer.getBoundingClientRect().width;
                        outer.style.overflow = 'scroll';
                        var inner = this.createHtmlElement('div', {
                            'style': 'width:100%'
                        });
                        outer.appendChild(inner);
                        var widthWithScroll = inner.getBoundingClientRect().width;
                        outer.parentNode.removeChild(outer);
                        var svgBounds = {
                            x: 0,
                            y: 0,
                            width: widthNoScroll - widthWithScroll,
                            height: 0
                        };
                        return svgBounds;
                    },
                    pathPoints: function pathPoints(pathPointsObj) {
                        return __awaiter(this, void 0, void 0, function () {
                            var pathPoints, result, i, data;
                            return __generator(this, function (_a) {
                                pathPoints = {};

                                if (pathPointsObj) {
                                    result = Object.keys(pathPointsObj).map(function (key) {
                                        return [pathPointsObj[key], key];
                                    });

                                    for (i = 0; i < result.length; i++) {
                                        if (result.length > 0) {
                                            data = result[i][1];
                                            pathPoints[result[i][0]] = this.findSegmentPoints(data);
                                        }
                                    }
                                }

                                return [2
                                    /*return*/
                                    , pathPoints];
                            });
                        });
                    },
                    findSegmentPoints: function findSegmentPoints(pathData) {
                        var pts = [];
                        var sample;
                        var sampleLength;
                        var measureWindowElement = 'measureElement';
                        window[measureWindowElement].style.visibility = 'visible';
                        var svg = window[measureWindowElement].children[2];
                        var pathNode = this.getChildNode(svg)[0];
                        pathNode.setAttributeNS(null, 'd', pathData);
                        var pathLength = pathNode.getTotalLength();

                        for (sampleLength = 0; sampleLength <= pathLength; sampleLength += 10) {
                            sample = pathNode.getPointAtLength(sampleLength);
                            pts.push({
                                x: sample.x,
                                y: sample.y
                            });
                        }

                        window[measureWindowElement].style.visibility = 'hidden';
                        return pts;
                    },
                    loadImage: function loadImage(images, value, result) {
                        return __awaiter(this, void 0, void 0, function () {
                            var promise, _a, _b;

                            return __generator(this, function (_c) {
                                switch (_c.label) {
                                    case 0:
                                        promise = new Promise(function (resolve, reject) {
                                            var imageSize = {};
                                            var measureWindowElement = 'measureElement';
                                            window[measureWindowElement].style.visibility = 'visible';
                                            var imageElement = window[measureWindowElement].children[1];
                                            imageElement.setAttribute('src', images[value][0]);
                                            window[measureWindowElement].style.visibility = 'hidden';
                                            var element = document.createElement('img');
                                            element.setAttribute('src', images[value][0]);
                                            setAttributeHtml(element, {
                                                id: "imagesf" + value + "imageNode",
                                                style: 'display: none;'
                                            });
                                            document.body.appendChild(element);

                                            element.onload = function (event) {
                                                var loadedImage = event.currentTarget;
                                                imageSize = {
                                                    width: loadedImage.width,
                                                    height: loadedImage.height
                                                };
                                                resolve(imageSize);
                                            };
                                        });
                                        _a = result;
                                        _b = images[value][1];
                                        return [4
                                            /*yield*/
                                            , promise];

                                    case 1:
                                        _a[_b] = _c.sent();
                                        if (!(value == images.length - 1)) return [3
                                            /*break*/
                                            , 2];
                                        return [2
                                            /*return*/
                                            , result];

                                    case 2:
                                        value++;
                                        return [4
                                            /*yield*/
                                            , this.loadImage(images, value, result)];

                                    case 3:
                                        _c.sent();

                                        _c.label = 4;

                                    case 4:
                                        return [2
                                            /*return*/
                                        ];
                                }
                            });
                        });
                    },
                    bBoxText: function bBoxText(textContent, options) {
                        var measureWindowElement = 'measureElement';
                        window[measureWindowElement].style.visibility = 'visible';
                        var svg = window[measureWindowElement].children[2];
                        var text = this.getChildNode(svg)[1];
                        text.textContent = textContent;
                        applyStyleAgainstCsp(text, 'font-size:' + options.fontSize + 'px; font-family:' + options.fontFamily + ';font-weight:' + (options.bold ? 'bold' : 'normal'));
                        var bBox = text.getBBox().width;
                        window[measureWindowElement].style.visibility = 'hidden';
                        return bBox;
                    },
                    endEdit: function endEdit(e) {
                        setTimeout(function () {
                            var nodeTextbox = document.getElementById(annotation.id + "_text");

                            if (nodeTextbox) {
                                nodeTextbox.setAttribute("visibility", "visible");
                            }
                        }, 100);
                        var textBoxDiv = "diagram_editTextBoxDiv";
                        var editBoxDiv = "diagram_editBox";
                        var textArea = this[editBoxDiv];
                        var annotation = window['annotation'];
                        var content = window['isEscape'] ? annotation.content : textArea.value;
                        var style = annotation.style;
                        var size = annotation.bounds;
                        var nodeSize = annotation.nodeSize;
                        nodeSize.width = nodeSize.width == null ? undefined : nodeSize.width;
                        nodeSize.height = nodeSize.height == null ? undefined : nodeSize.height;
                        var annotationValue = {};
                        var finalResult = {};
                        annotationValue[annotation.id] = this.measureText(size, style, content, size.width || nodeSize.width);
                        annotationValue[annotation.id].Content = content;
                        finalResult["Text"] = annotationValue;
                        var textBoxEditElement = this[textBoxDiv];
                        textBoxEditElement.remove();
                        return finalResult;
                    },
                    onAddWireEvents: function onAddWireEvents(id, component) {
                        var _this = this;

                        var element = document.getElementById(id);
                        element.addEventListener('mousedown', function (e) {
                            _this.invokeDiagramEvents(e, component);
                        });
                        element.addEventListener('mousemove', function (e) {
                            _this.invokeDiagramEvents(e, component);
                        });
                        element.addEventListener('mouseup', function (e) {
                            _this.invokeDiagramEvents(e, component);
                        });
                        element.addEventListener('mouseleave', function (e) {
                            _this.invokeDiagramEvents(e, component);
                        });
                        element.addEventListener('scroll', function (e) {
                            _this.invokeDiagramEvents(e, component);
                        });
                        element.addEventListener('mousewheel', function (e) {
                            _this.invokeDiagramEvents(e, component);
                        });
                        element.addEventListener('keydown', function (e) {
                            _this.invokeDiagramEvents(e, component);
                        });
                        element.addEventListener('keyup', function (e) {
                            _this.invokeDiagramEvents(e, component);
                        });
                    },
                    invokeDiagramEvents: function invokeDiagramEvents(e, component) {
                        var finalResult;
                        var textBoxDiv = "diagram_editTextBoxDiv";
                        var editTextBoxDiv = this[textBoxDiv];
                        var args = {};
                        var action;

                        if (e.type == "mousedown") {
                            action = true;
                        }

                        if (e.type == "mouseup") {
                            action = false;
                        }

                        if ((e.type == "mouseleave" || e.key == "Escape" || e.type == "mousedown" && e.target.id != "diagram_editBox") && editTextBoxDiv) {
                            window['isEscape'] = e.key == "Escape" ? true : false;
                            finalResult = this.endEdit(e, this);
                            this[textBoxDiv] = editTextBoxDiv = document.getElementById("diagram_editTextBoxDiv");
                        }

                        args = this.getMouseEvents(e);

                        if (e.key == "Escape") {
                            var helperElements = "helperElement";
                            var helperElement = document.getElementById(helperElements);

                            if (helperElement) {
                                sf.base.remove(helperElement);
                                helperElement.remove();
                            }
                        }

                        if (!editTextBoxDiv && (e.type == "mousemove" && !eventStarted || e.type != "mousemove" || !inAction)) {
                            if (e.type == "mousemove" && action && isZoomPan) {
                                eventStarted = true;
                                args.eventInvokeValue = ++eventInvokeValue;
                            }

                            if (e.type == "keydown" || e.type == "keyup" || e.type != "scroll" || e.type == "scroll" && !isMouseWheel) {
                                component.invokeMethodAsync('InvokeDiagramEvents', args, finalResult);
                            }
                        }

                        if (e.type == "mouseup" || e.type == "mousemove" && !this[textBoxDiv]) {
                            e.currentTarget.focus();
                        }
                    },
                    isForeignObject: function isForeignObject(target, isTextBox) {
                        var foreignobject = target;

                        if (foreignobject) {
                            while (foreignobject.parentNode !== null) {
                                if (typeof foreignobject.className === 'string' && (!isTextBox && foreignobject.className.indexOf('foreign-object') !== -1 || isTextBox && foreignobject.className.indexOf('e-diagram-text-edit') !== -1)) {
                                    return foreignobject;
                                } else {
                                    foreignobject = foreignobject.parentNode;
                                }
                            }
                        }

                        return null;
                    },
                    getMouseEvents: function getMouseEvents(evt) {
                        var mouseEventArgs = {};
                        mouseEventArgs = {
                            altKey: evt.altKey,
                            shiftKey: evt.shiftKey,
                            ctrlKey: evt.ctrlKey,
                            detail: evt.detail,
                            metaKey: evt.metaKey,
                            screenX: evt.screenX,
                            screenY: evt.screenY,
                            clientX: evt.clientX,
                            clientY: evt.clientY,
                            offsetX: evt.offsetX,
                            offsetY: evt.offsetY,
                            type: evt.type,
                            key: evt.key,
                            keyCode: evt.keyCode,
                            button: evt.button
                        };

                        if (evt.currentTarget) {
                            var bounds = this.measureScrollValues(evt.currentTarget.id);
                            mouseEventArgs.diagramCanvasScrollBounds = bounds;
                            mouseEventArgs.diagramGetBoundingClientRect = evt.currentTarget.getBoundingClientRect();
                        } else if (evt.target) {
                            var bounds = this.measureScrollValues(evt.target.id);
                            mouseEventArgs.diagramCanvasScrollBounds = bounds;
                            mouseEventArgs.diagramGetBoundingClientRect = evt.target.getBoundingClientRect();
                        }

                        if (evt.type == "mousewheel") {
                            evt.preventDefault();
                            evt.currentTarget.focus();
                            mouseEventArgs.wheelDelta = evt.wheelDelta;
                            isMouseWheel = true;
                        }

                        if (evt.type == "mousedown") {
                            inAction = true;
                        }

                        if (evt.type == "mouseup") {
                            inAction = false;
                        }

                        if (!this.isForeignObject(evt.target, true) && (evt.type == "mouseleave" || evt.type == "mousmove" || evt.type == "mousedown" || evt.type == "mouseup" || evt.type == "keydown" || evt.type == "keyup")) {
                            evt.preventDefault();
                        }

                        return mouseEventArgs;
                    },
                    //Symbol palette Snippet Starts here 
                    initialiseModule: function initialiseModule(element, component, allowDrag) {
                        return __awaiter(this, void 0, void 0, function () {
                            var symbolPaletteInstance, object, object;

                            var _this = this;

                            return __generator(this, function (_a) {
                                symbolPaletteInstance = 'symbolPaletteInstance';

                                if (window[symbolPaletteInstance]) {
                                    object = {
                                        id: element.children[0].id,
                                        componentInstance: component,
                                        allowDrag: allowDrag
                                    };
                                    window[symbolPaletteInstance].push(object);
                                } else {
                                    object = {
                                        id: element.children[0].id,
                                        componentInstance: component,
                                        allowDrag: allowDrag
                                    };
                                    window[symbolPaletteInstance] = [];
                                    window[symbolPaletteInstance].push(object);
                                }

                                element.addEventListener('mousedown', function (e) {
                                    _this.invokePaletteEvents(e, component);
                                });
                                element.addEventListener('mousemove', function (e) {
                                    _this.invokePaletteEvents(e, component);
                                });
                                element.addEventListener('mouseup', function (e) {
                                    _this.invokePaletteEvents(e, component);
                                });
                                element.addEventListener('mouseleave', function (e) {
                                    _this.invokePaletteEvents(e, component);
                                });
                                setTimeout(function () {
                                    this.symbolPaletteDragAndDropModule = new InitDraggable(element, window[symbolPaletteInstance]);
                                }, 100);
                                return [2
                                    /*return*/
                                ];
                            });
                        });
                    },
                    invokePaletteEvents: function invokePaletteEvents(e, component) {
                        var invokePaletteEvents = "InvokePaletteEvents";
                        var symbolDraggableClass = "e-symbol-draggable";
                        var symbolhoverClass = "e-symbol-hover";
                        var symbolId;
                        e.preventDefault();
                        var args = this.palettegetMouseEvents(e);

                        if (e.target.id.split('_').length === 2) {
                            symbolId = e.target.id.split('_')[0];
                        }

                        if (e.type == "mousemove" && !eventStarted || e.type != "mousemove" || !inAction) {
                            if (e && e.target && e.type) {
                                var element = document.getElementById(e.target.id);
                                var container = void 0;

                                if (element) {
                                    for (var k = 0; k < element.classList.length; k++) {
                                        if (element.classList[k] == symbolDraggableClass) {
                                            container = e.target;
                                            container.classList.add(symbolhoverClass);
                                            break;
                                        }
                                    }

                                    var hoverElementCount = document.getElementsByClassName(symbolhoverClass);

                                    if (hoverElementCount && hoverElementCount.length > 0) {
                                        for (var a = 0; a < hoverElementCount.length; a++) {
                                            var oldcontainer = hoverElementCount[a];

                                            if (container && container != oldcontainer || container == undefined) {
                                                oldcontainer.classList.remove(symbolhoverClass);
                                            }
                                        }
                                    }
                                }
                            }

                            component.invokeMethodAsync(invokePaletteEvents, args, symbolId);
                        }
                    },
                    palettegetMouseEvents: function palettegetMouseEvents(evt) {
                        var mouseEventArgs = {};
                        mouseEventArgs = {
                            altKey: evt.altKey,
                            shiftKey: evt.shiftKey,
                            ctrlKey: evt.ctrlKey,
                            detail: evt.detail,
                            metaKey: evt.metaKey,
                            screenX: evt.screenX,
                            screenY: evt.screenY,
                            clientX: evt.clientX,
                            clientY: evt.clientY,
                            offsetX: evt.offsetX,
                            offsetY: evt.offsetY,
                            type: evt.type
                        };
                        return mouseEventArgs;
                    },

                    /**
                         * To Export the diagram
                         *
                         * @private
                         */
                    exportDiagram: function (options, diagram) {
                        return __awaiter(this, void 0, void 0, function () {
                            var fileType, customBounds, content, content1, data, buffers, margin, region, mode, bounds, nodes, fileName, svg, svgData, buffer, browserInfo, b, blob, pom, url, e;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        content1 = '';
                                        data = 'data';
                                        Diagram = diagram;
                                        buffers = [];
                                        margin = options.margin || {};
                                        region = options && options.region ? options.region : 'Content';
                                        mode = options && options.mode ? options.mode : 'Download';
                                        bounds = this.getDiagramBounds(region, options);
                                        if (options.bounds) {
                                            customBounds = true;
                                            bounds.x = options.bounds.x ? options.bounds.x : bounds.x;
                                            bounds.y = options.bounds.y ? options.bounds.y : bounds.y;
                                            bounds.width = options.bounds.width || bounds.width;
                                            bounds.height = options.bounds.height || bounds.height;
                                        }
                                        margin = {
                                            top: margin.top !== undefined ? margin.top : 25,
                                            bottom: margin.bottom !== undefined ? margin.bottom : 25,
                                            right: margin.right !== undefined ? margin.right : 25,
                                            left: margin.left !== undefined ? margin.left : 25
                                        };
                                        nodes = Diagram.nodes;
                                        if (region !== 'PageSettings') {
                                            bounds.x -= margin.left;
                                            bounds.y -= margin.top;
                                            bounds.width += margin.left + margin.right;
                                            bounds.height += margin.top + margin.bottom;
                                        }
                                        fileName = options.fileName || 'diagram';
                                        if (!(options.format !== 'SVG')) return [3, 2];
                                        return [4, this.setCanvas(options, bounds, margin, mode, customBounds, region, fileName)];
                                    case 1:
                                        data = _a.sent();
                                        if (data !== null) {
                                            return [2, data];
                                        }
                                        return [3, 3];
                                    case 2:
                                        fileType = options.format;
                                        options.bounds = bounds;
                                        options.margin = margin;
                                        svg = content = this.diagramAsSvg(options, margin);
                                        if (mode === 'Data') {
                                            if (options.format === 'SVG') {
                                                svgData = new XMLSerializer().serializeToString(svg);
                                                return [2, svgData];
                                            }
                                            return [2, content];
                                        }
                                        buffer = new XMLSerializer().serializeToString(svg);
                                        buffers.push(buffer);
                                        _a.label = 3;
                                    case 3:
                                        if (mode === 'Download' && data !== null) {
                                            browserInfo = void 0;
                                            for (b = 0; b < buffers.length; b++) {
                                                blob = new Blob([buffers[b]], { type: 'application/octet-stream' });
                                                if (ej2_base_1.Browser.info.name === 'msie') {
                                                    window.navigator.msSaveOrOpenBlob(blob, fileName + '.' + fileType);
                                                }
                                                else {
                                                    pom = dom_util_1.createHtmlElement('a', { 'download': fileName + '.' + fileType });
                                                    url = URL.createObjectURL(blob);
                                                    pom.href = url;
                                                    e = document.createEvent('MouseEvents');
                                                    e.initMouseEvent('click', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
                                                    pom.dispatchEvent(e);
                                                }
                                            }
                                        }
                                        return [2, null];
                                }
                            });
                        });
                    },

                    /**   @private  */
                    getDiagramBounds: function getDiagramBounds(mode, options) {
                        var rect = this.getObjectsBound(options);
                        var left = rect.left;
                        var top = rect.top;
                        var right = rect.right - rect.left;
                        var bottom = rect.bottom - rect.top;

                        if (mode !== 'Content') {
                            if (Diagram.pageSettings && Diagram.pageSettings.multiplePage) {
                                left = rect.left;
                                top = rect.top;

                                if (Diagram.pageSettings.width) {
                                    left = Math.floor(left / Diagram.pageSettings.width) * Diagram.pageSettings.width;
                                    right = Math.ceil(rect.right / Diagram.pageSettings.width) * Diagram.pageSettings.width - left;
                                }

                                if (Diagram.pageSettings.height) {
                                    top = Math.floor(top / Diagram.pageSettings.height) * Diagram.pageSettings.height;
                                    bottom = Math.ceil(rect.bottom / Diagram.pageSettings.height) * Diagram.pageSettings.height - top;
                                }

                                if (rect.width === 0 && Diagram.pageSettings.width !== null) {
                                    right = Diagram.pageSettings.width;
                                }

                                if (rect.height === 0 && Diagram.pageSettings.height !== null) {
                                    bottom = Diagram.pageSettings.height;
                                }
                            } else {
                                if (Diagram.pageSettings.width) {
                                    left = 0;
                                    right = Diagram.pageSettings.width;
                                }

                                if (Diagram.pageSettings.height) {
                                    top = 0;
                                    bottom = Diagram.pageSettings.height;
                                }
                            }
                        }

                        var svgBounds = new Rect();
                        svgBounds.x = left;
                        svgBounds.y = top;
                        svgBounds.width = right;
                        svgBounds.height = bottom;
                        return svgBounds;
                    },

                    /**   @private  */
                    getObjectsBound: function getObjectsBound(options) {
                        var nodes = Diagram.nodes;
                        var nodebounds;

                        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
                            var node = nodes_1[_i];

                            if (node.visible) {
                                // if (((options.format !== 'SVG' && !(node instanceof DiagramNativeElement) && !(node instanceof DiagramHtmlElement))
                                //     || (options.format === 'SVG' && !(node instanceof DiagramHtmlElement)))) 
                                {
                                    if (!nodebounds) {
                                        nodebounds = node.wrapper.outerBounds;
                                    } else {
                                        nodebounds = nodebounds.uniteRect(node.wrapper.outerBounds);
                                    }
                                }
                            }
                        }

                        var connectors = Diagram.connectors;

                        for (var _a = 0, connectors_1 = connectors; _a < connectors_1.length; _a++) {
                            var connector = connectors_1[_a];

                            if (connector.visible) {
                                if (!nodebounds) {
                                    nodebounds = connector.wrapper.outerBounds;
                                } else {
                                    nodebounds = nodebounds.uniteRect(connector.wrapper.outerBounds);
                                }
                            }
                        }

                        return nodebounds || new Rect(0, 0, 0, 0);
                    },
                    setCanvas: function (options, bounds, margin, mode, customBounds, region, fileName) {
                        return __awaiter(this, void 0, void 0, function () {
                            var content, scaleX, scaleY, scaleOffsetX, scaleOffsetY, canvas, image, storeFormat;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        options.bounds = bounds;
                                        options.region = region;
                                        scaleX = 'scaleX';
                                        scaleY = 'scaleY';
                                        scaleOffsetX = 'scaleOffsetX';
                                        scaleOffsetY = 'scaleOffsetY';
                                        this.setScaleValueforCanvas(options, bounds);
                                        return [4, this.exportAsImage(options.type, fileName, Diagram, mode !== 'Download')];
                                    case 1:
                                        canvas = _a.sent();
                                        if (options.format === 'JPG') {
                                            image = content = storeFormat = canvas.toDataURL('image/jpeg');
                                        }
                                        else if (options.format === 'BMP') {
                                            image = content = storeFormat = canvas.toDataURL('image/bmp');
                                        }
                                        else {
                                            
                                            image = content = storeFormat = (options.format === 'JPEG') ? canvas.toDataURL('image/jpeg') :
                                                (options.format === 'PNG') ? canvas.toDataURL('image/png') : canvas;
                                        }
                                        if (mode === 'Data') {
                                            return [2, content];
                                        }
                                        this.canvasMultiplePage(options, canvas, margin, image, fileName);
                                        return [2, null];
                                }
                            });
                        });
                    },
                    exportAsImage: function (exportType, fileName, element, isReturnBase64) {
                        return __awaiter(this, void 0, void 0, function () {
                            var returnValue;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4/*yield*/, this.imageExport(exportType, fileName, element, isReturnBase64)];
                                    case 1:
                                        returnValue = _a.sent();
                                        if (returnValue instanceof Promise) {
                                            returnValue.then(function (data) {
                                                return data;
                                            });
                                            return [2 /*return*/, returnValue];
                                        }
                                        else {
                                            return [2 /*return*/, returnValue];
                                        }
                                        return [2  /*return*/];
                                }
                            });
                        });
                    },
                    imageExport: function (type, fileName, element, isReturnBase64) {
                        return __awaiter(this, void 0, void 0, function () {
                            var instance, promise;
                            var _this = this;
                            var elementId = document.getElementById(element.id);
                            return __generator(this, function (_a) {
                                instance = this;
                                promise = new Promise(function (resolve, reject) {
                                    var svgData = '<svg xmlns=' + 'http://www.w3.org/2000/svg' + ' xmlns:xlink=' + 'http://www.w3.org/1999/xlink' + '>'
                                        + element + '</svg>';
                                    var element1 = document.getElementById(element.id + '_diagramLayer' + '_svg');
 
                                    var serializer = 'XMLSerializer';
                                    var url = window.URL.createObjectURL(new Blob([new window[serializer]().serializeToString(element1)], {
                                        type: 'image/svg+xml'
                                    }));
                                    //var url = window.URL.createObjectURL(new Blob(type === 'SVG' ? [svgData] : [new window[serializer]().serializeToString(element)], { type: 'image/svg+xml' }));
                                    if (type === 'SVG') {
                                        _this.triggerDownload(type, fileName, url);
                                        resolve(null);
                                    }
                                    else {
                                        var canvasElement_1 = document.createElement('canvas');
                                        canvasElement_1.height = elementId.clientHeight;
                                        canvasElement_1.width = elementId.clientWidth;
                                        var context_1 = canvasElement_1.getContext('2d');
                                        var image_1 = new Image();
                                        
                                        image_1.onload = function () {
                                            context_1.drawImage(image_1, 0, 0);
                                            //window.URL.revokeObjectURL(url);
                                            if (!isReturnBase64) {
                                                _this.triggerDownload('JPG', fileName, canvasElement_1.toDataURL('image/png').replace('image/png', 'image/octet-stream'));
                                                resolve(null);
                                            }
                                            else {
                                                var base64String = (type === 'JPEG') ? canvasElement_1.toDataURL('image/jpeg') :
                                                    (type === 'PNG') ? canvasElement_1.toDataURL('image/png') : canvasElement_1.toDataURL();
                                                resolve(base64String);
                                            }
                                        };
                                        image_1.src = url;
                                    }
                                });
                                return [2 /*return*/, promise];
                            });
                        });
                    },
                    blobToBase64: function blobToBase64(blob, callback) {
                        var reader = new FileReader();
                        reader.onload = function () {
                            var dataUrl = reader.result;
                            var base64 = dataUrl.split(',')[1];
                            callback(base64);
                        };
                        reader.readAsDataURL(blob);
                    },
                    canvasMultiplePage: function canvasMultiplePage(options, canvas, margin, image, fileName) {
                        var _this = this;

                        var images = [];
                        var imageData = image.substring(image.indexOf(":") + 1, image.indexOf(";"));
                        var imageFormat = imageData.substring(imageData.indexOf("/") + 1);

                        if (imageFormat === 'jpeg') {
                            imageFormat = undefined;
                        } else {
                            imageFormat = imageFormat.toUpperCase();
                        }

                        var fileType = imageFormat || 'JPG';

                        if (options.multiplePage) {
                            options.pageHeight = options.pageHeight ? options.pageHeight : Diagram.pageSettings.height;
                            options.pageWidth = options.pageWidth ? options.pageWidth : Diagram.pageSettings.width;
                            options.pageHeight = options.pageHeight ? options.pageHeight : canvas.width;
                            options.pageWidth = options.pageWidth ? options.pageWidth : canvas.height;
                            margin = options.margin || {};

                            if (options.pageOrientation) {
                                if (options.pageOrientation === 'Landscape' && options.pageHeight > options.pageWidth || options.pageOrientation === 'Portrait' && options.pageWidth > options.pageHeight) {
                                    var temp = options.pageWidth;
                                    options.pageWidth = options.pageHeight;
                                    options.pageHeight = temp;
                                }
                            }

                            options.margin = {
                                top: !isNaN(margin.top) ? margin.top : 0,
                                bottom: !isNaN(margin.bottom) ? margin.bottom : 0,
                                left: !isNaN(margin.left) ? margin.left : 0,
                                right: !isNaN(margin.right) ? margin.right : 0
                            };
                            var attr = {
                                'id': Diagram.id + '_printImage',
                                'src': image
                            };
                            var img_1 = this.createHtmlElement('img', attr);

                            img_1.onload = function () {
                                images = _this.getMultipleImage(img_1, options, true);

                                _this.exportImage(images, fileName, fileType, image);
                            };
                        } else {
                            images = [image];
                            this.exportImage(images, fileName, fileType, image);
                        }
                    },
                    exportImage: function exportImage(images, fileName, fileType, image) {
                        var buffers = [];
                        var length = !(images instanceof HTMLElement) ? images.length : 0;

                        for (var g = 0; g < length; g++) {
                            image = images[g];
                            image = image.replace(/^data:[a-z]*;,/, '');
                            var image1 = image.split(',');
                            var byteString = atob(image1[1]);
                            var buffer = new ArrayBuffer(byteString.length);
                            var intArray = new Uint8Array(buffer);

                            for (var i = 0; i < byteString.length; i++) {
                                intArray[i] = byteString.charCodeAt(i);
                            }

                            buffers.push(buffer);
                        }

                        var _loop_1 = function _loop_1(j) {
                            var b = new Blob([buffers[j]], {
                                type: 'application/octet-stream'
                            });

                            if (sf.base.Browser.info.name === 'msie') {
                                window.navigator.msSaveOrOpenBlob(b, fileName + '.' + fileType);
                            } else {
                                var htmlElement_1 = this.createHtmlElement('a', {
                                    'download': fileName + '.' + fileType
                                });
                                var urlLink = URL.createObjectURL(b);
                                htmlElement_1.href = urlLink;
                                var mouseEvent_1 = document.createEvent('MouseEvents');
                                mouseEvent_1.initMouseEvent('click', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
                                setTimeout(function () {
                                    htmlElement_1.dispatchEvent(mouseEvent_1);
                                }, (j + 1) * 5);
                            }
                        }; // Ensure this for safari
                        // if (Browser.info.name === 'msie' && Number(Browser.info.version) < 10 || Browser.info.name === 'webkit') {
                        //     let browserInfo: string = Browser.info.name === 'webkit' ? 'Safari' : 'IE-9';
                        //     alert('Downloading option is not supported in ' + browserInfo + ', Please use the returned data');
                        //     return content;
                        // } else {


                        for (var j = 0; j < buffers.length; j++) {
                            _loop_1(j);
                        }
                    },
                    setScaleValueforCanvas: function setScaleValueforCanvas(options, bounds) {
                        var scaleX = 'scaleX';
                        var scaleY = 'scaleY';
                        var scaleOffsetX = 'scaleOffsetX';
                        var scaleOffsetY = 'scaleOffsetY';
                        options[scaleX] = 1;
                        options[scaleY] = 1;
                        options[scaleOffsetX] = 0;
                        options[scaleOffsetY] = 0;
                        options.pageHeight = options.pageHeight || Diagram.pageSettings.height;
                        options.pageWidth = options.pageWidth || Diagram.pageSettings.width;
                        var pageOrientation = options.pageOrientation || Diagram.pageSettings.orientation;

                        if (!pageOrientation) {
                            pageOrientation = 'Portrait';
                        }

                        if (pageOrientation === 'Portrait') {
                            if (options.pageWidth > options.pageHeight) {
                                var temp = options.pageHeight;
                                options.pageHeight = options.pageWidth;
                                options.pageWidth = temp;
                            }
                        } else {
                            if (options.pageHeight > options.pageWidth) {
                                var temp = options.pageWidth;
                                options.pageWidth = options.pageHeight;
                                options.pageHeight = temp;
                            }
                        }

                        if (options.pageWidth && options.pageHeight && !options.multiplePage) {
                            options.stretch = 'Meet';
                        }

                        var height = options.pageHeight || bounds.height;
                        var width = options.pageWidth || bounds.width;

                        if (options.stretch === 'Stretch' || options.stretch === 'Meet' || options.stretch === 'Slice') {
                            options[scaleX] = width / bounds.width;
                            options[scaleY] = height / bounds.height;

                            if (options.stretch === 'Meet') {
                                options[scaleX] = options[scaleY] = Math.min(options[scaleX], options[scaleY]);
                                options[scaleOffsetY] = (options.pageHeight - bounds.height * options[scaleX]) / 2;
                                options[scaleOffsetX] = (options.pageWidth - bounds.width * options[scaleX]) / 2;
                            } else if (options.stretch === 'Slice') {
                                options[scaleX] = options[scaleY] = Math.max(options[scaleX], options[scaleY]);
                            }

                            bounds.width = width;
                            bounds.height = height;
                        }

                        bounds.x *= options[scaleX];
                        bounds.y *= options[scaleY];
                    },
                    diagramAsSvg: function diagramAsSvg(options, margin) {
                        var svg = Diagram.createSvg(Diagram.id + '_diagram_svg', options.bounds.width, options.bounds.height);
                        document.body.appendChild(svg);
                        var g = createSvgElement('g', {
                            'id': Diagram.id + '_pageBackground'
                        });
                        var region = options && options.region ? options.region : 'Content';
                        var bounds = this.getDiagramBounds(region, options);
                        var left = bounds.x;
                        var top = bounds.y;
                        var width = bounds.width;
                        var height = bounds.height;
                        svg.appendChild(g);
                        var attr = {
                            'x': String(left),
                            'y': String(top),
                            'width': String(width),
                            'height': String(height)
                        };
                        setAttributeSvg(g, attr);
                        this.setTransform(g, options.bounds, margin);
                        var gradient = document.getElementById(Diagram.id + 'gradient_pattern');

                        if (gradient) {
                            svg.appendChild(gradient);
                        }

                        attr = {
                            'x': String(left),
                            'y': String(top),
                            'width': String(width + margin.left + margin.right),
                            'height': String(height + margin.top + margin.bottom)
                        };
                        var backimage = document.getElementById(Diagram.id + '_backgroundImageLayer').cloneNode(true);
                        setAttributeSvg(backimage, attr);
                        svg.appendChild(backimage);
                        this.setTransform(backimage, bounds, margin);
                        var backRect = document.getElementById(Diagram.id + '_backgroundLayerrect').cloneNode(true);
                        setAttributeSvg(backRect, attr);
                        svg.appendChild(backRect);
                        this.setTransform(backRect, bounds, margin);

                        if (Diagram.mode === 'SVG') {
                            var element = void 0;
                            var i = void 0;
                            var diagramLayerSVG = getDiagramLayerSvg(Diagram.id);
                            svg.appendChild(diagramLayerSVG.getElementById(Diagram.diagramLayer.id).cloneNode(true));

                            for (i = 0; i < svg.childNodes.length; i++) {
                                element = svg.childNodes[i];

                                if (element.id === Diagram.id + '_diagramLayer') {
                                    this.setTransform(element, bounds, margin);
                                }
                            }
                        } else {
                            g = createSvgElement('g', {
                                'id': Diagram.id + '_diagramLayer'
                            });
                            svg.appendChild(g);
                            this.setTransform(g, options.bounds, margin); //renderLabels

                            var renderer = new DiagramRenderer('', null, true);
                            var htmlLayer = getHTMLLayer(Diagram.id);
                            Diagram.renderDiagramElements(svg, renderer, htmlLayer, false);
                        }

                        document.body.removeChild(svg);
                        return svg;
                    },
                    setTransform: function setTransform(element, bounds, margin) {
                        element.setAttribute('transform', 'translate(' + (-bounds.x + margin.left) + ', ' + (-bounds.y + margin.top) + ')');
                    },
                    setCanvasSize: function (canvas, width, height) {
                        if (canvas) {
                            canvas.setAttribute('width', width.toString());
                            canvas.setAttribute('height', height.toString());
                        }
                    },
                    createCanvas: function (id, width, height) {
                        var canvasObj = this.createHtmlElement('canvas', { 'id': id });
                        this.setCanvasSize(canvasObj, width, height);
                        return canvasObj;
                    },
                    getHTMLLayer: function getHTMLLayer(diagramId) {
                        var htmlLayer = null;
                        var domTable = 'domTable';
                        if (!window[diagramId + '_htmlLayer']) {
                            var element = getDiagramElement(diagramId);
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            var elementcoll = element.getElementsByClassName('e-html-layer');
                            htmlLayer = elementcoll[0];
                            window[diagramId + '_htmlLayer'] = htmlLayer;
                        }
                        else {
                            htmlLayer = window[diagramId + '_htmlLayer'];
                        }
                        return htmlLayer;
                    },
                    getDiagramElement: function getDiagramElement(elementId, contentId) {
                        var diagramElement;
                        var element;
                        if (contentId) {
                            element = document.getElementById(contentId);
                        }
                        if (Browser.info.name === 'msie' || Browser.info.name === 'edge') {
                            diagramElement = (element) ? element.querySelector('#' + elementId) : document.getElementById(elementId);
                        }
                        else {
                            diagramElement = (element) ? element.querySelector('#' + CSS.escape(elementId)) : document.getElementById(elementId);
                        }
                        return diagramElement;
                    },
                    diagramAsCanvas: function diagramAsCanvas(options, customBounds) {
                        var scaleX = 'scaleX';
                        var scaleY = 'scaleY';
                        var scaleOffsetX = 'scaleOffsetX';
                        var scaleOffsetY = 'scaleOffsetY';
                        var element;
                        var elements = [];
                        var region = options.bounds;
                        var margin = options.margin;
                        var mode = options && options.region ? options.region : 'Content';
                        var pageBounds = this.getDiagramBounds(mode, options);
                        var bgColor = Diagram.pageSettings.background.color;
                        var canvas = this.createCanvas(Diagram.id + '_diagram', options.bounds.width, options.bounds.height); //canvas.setAttribute('style', 'position:absolute;top:135px;left:160px;');

                        var context = canvas.getContext('2d');
                        context.translate(-region.x, -region.y);
                        context.save();
                        context.fillStyle = Diagram.pageSettings.background.color === 'transparent' ? 'white' : Diagram.pageSettings.background.color;
                        region = mode === 'Content' ? pageBounds : region;
                        context.fillRect(region.x, region.y, region.width, region.height);
                        var bgImg = Diagram.pageSettings.background;

                        if (bgImg && bgImg.source) {
                            pageBounds = this.getDiagramBounds(mode, options);
                            var image = new Image();
                            image.src = bgImg.source;
                            var proportionX = pageBounds.width / image.width;
                            var proportionY = pageBounds.height / image.height;
                            var x = pageBounds.x;
                            var y = pageBounds.y;
                            var width = pageBounds.width;
                            var height = pageBounds.height;
                            var exportable = this.isImageExportable(bgImg);

                            if (bgImg.scale !== 'None' && bgImg.align !== 'None') {
                                var proportion = bgImg.scale === 'Meet' ? Math.min(proportionX, proportionY) : Math.max(proportionX, proportionY);
                                width = proportion * image.width;
                                height = proportion * image.height;

                                if (bgImg.align.indexOf('xmid') > -1) {
                                    x += (pageBounds.width - width) / 2;
                                } else if (bgImg.align.indexOf('xmax') > -1) {
                                    x = x + pageBounds.width - width;
                                }

                                if (bgImg.align.indexOf('ymid') > -1) {
                                    y += (pageBounds.height - height) / 2;
                                } else if (bgImg.align.indexOf('ymax') > -1) {
                                    y = y + pageBounds.height - height;
                                }

                                if (Diagram.pageSettings.background.color === 'none' || Diagram.pageSettings.background.color === 'transparent') {
                                    context.fillStyle = 'white';
                                    context.fillRect(pageBounds.x * options[scaleX], pageBounds.y * options[scaleY], pageBounds.width * options[scaleX], pageBounds.height * options[scaleY]);
                                }

                                if (exportable) {
                                    context.drawImage(image, x, y, proportion * image.width, proportion * image.height);
                                }
                            } else if (exportable) {
                                context.drawImage(image, x, y, pageBounds.width, pageBounds.height);
                            }
                        } else {
                            context.fillStyle = bgColor === 'transparent' ? 'white' : bgColor;
                            context.fillRect(pageBounds.x * options[scaleX] - margin.left, pageBounds.y * options[scaleY] - margin.top, pageBounds.width * options[scaleX] + margin.left + margin.right, options[scaleY] * pageBounds.height + margin.top + margin.bottom);
                        }

                        var brColor = Diagram.pageSettings.background.color;
                        var brWidth = Diagram.pageSettings.width;

                        if (brWidth) {
                            context.strokeStyle = brColor === 'none' ? 'transparent' : brColor;
                            context.lineWidth = brWidth;
                            context.strokeRect(pageBounds.x * options[scaleX], pageBounds.y * options[scaleY], pageBounds.width * options[scaleX], pageBounds.height * options[scaleY]);
                        }

                        context.restore();
                        //var htmlLayer = this.getHTMLLayer(Diagram.id);
                        //var renderer = new DiagramRenderer('', null, false);
                        this.updateObjectValue(options[scaleX], options[scaleOffsetX], options[scaleOffsetY], true);
                        //Diagram.renderDiagramElements(canvas, renderer, htmlLayer, false, true);
                        //this.updateObjectValue(options[scaleX], options[scaleOffsetX], options[scaleOffsetY], false);

                        var element = document.getElementById(Diagram.id);
                        var svgData = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">' + element.outerHTML + '</svg>';
                        var url = window.URL.createObjectURL(new Blob(options.type === 'SVG' ? [svgData] : [(new XMLSerializer()).serializeToString(element)], { type: 'image/svg+xml' }));
                        if (options.type === 'SVG') {
                            if (options.mode === 'Download') {
                                this.triggerDownload(type, fileName, url);
                            }
                            
                        } else {
                           
                            var image = new Image();
                            image.onload = function () {
                                context.drawImage(image, 0, 0);
                                window.URL.revokeObjectURL(url);
                                if (options.mode === 'Download') {
                                    this.triggerDownload(type, fileName, canvas.toDataURL('image/png').replace('image/png', 'image/octet-stream'));
                                    resolve(null);
                                } else {
                                    var base64String = (type === 'JPEG') ? canvas.toDataURL('image/jpeg') : (type === 'PNG') ? canvas.toDataURL('image/png') : '';
                                    //resolve(base64String);
                                }
                            };
                            image.src = url;
                        }
                        return canvas;
                    },
                    triggerDownload: function (type, fileName, url) {
                        var anchorElement = document.createElement('a');
                        anchorElement.download = fileName + '.' + type.toLocaleLowerCase();
                        anchorElement.href = url;
                        anchorElement.click();
                    },
                    updateWrapper: function updateWrapper(canvas, value, scaleOffsetX, scaleOffsetY, isExport) {
                        if (canvas && canvas.length > 0) {
                            for (var j = 0; j < canvas.length; j++) {
                                if (canvas[j].children) {
                                    this.updateWrapper(canvas[j].children, value, scaleOffsetX, scaleOffsetY, isExport);
                                }

                                canvas[j].exportScaleValue.x = value;
                                canvas[j].exportScaleValue.y = value;
                                canvas[j].exportScaleOffset.x = scaleOffsetX;
                                canvas[j].exportScaleOffset.y = scaleOffsetY;
                                canvas[j].isExport = isExport;
                            }
                        }
                    },
                    scaleGradientValue: function scaleGradientValue(node, scaleValue, isExport) {
                        if (node.style.gradient && node.style.gradient.stops.length > 0) {
                            var gradients = node.style.gradient;

                            if (node.style.gradient instanceof LinearGradient) {
                                gradients.x1 = isExport ? gradients.x1 * scaleValue : gradients.x1 / scaleValue;
                                gradients.y1 = isExport ? gradients.y1 * scaleValue : gradients.y1 / scaleValue;
                                gradients.x2 = isExport ? gradients.x2 * scaleValue : gradients.x2 / scaleValue;
                                gradients.y2 = isExport ? gradients.y2 * scaleValue : gradients.y2 / scaleValue;
                            } else {
                                gradients.fx = isExport ? gradients.fx * scaleValue : gradients.fx / scaleValue;
                                gradients.fy = isExport ? gradients.fy * scaleValue : gradients.fy / scaleValue;
                                gradients.cx = isExport ? gradients.cx * scaleValue : gradients.cx / scaleValue;
                                gradients.cy = isExport ? gradients.cy * scaleValue : gradients.cy / scaleValue;
                                gradients.r = isExport ? gradients.r * scaleValue : gradients.r / scaleValue;
                            }
                        }
                    },
                    updateObjectValue: function updateObjectValue(value, scaleOffsetX, scaleOffsetY, isExport) {
                        var wrapper;

                        for (var i = 0; i < Diagram.nodes.length; i++) {
                            wrapper = Diagram.nodes[i].wrapper;
                            this.scaleGradientValue(Diagram.nodes[i], value, isExport);
                            if (wrapper) {
                                this.updateWrapper(wrapper.children, value, scaleOffsetX, scaleOffsetY, isExport);
                                wrapper.exportScaleValue.x = value;
                                wrapper.exportScaleValue.y = value;
                                wrapper.exportScaleOffset.x = scaleOffsetX;
                                wrapper.exportScaleOffset.y = scaleOffsetY;
                                wrapper.isExport = isExport;
                            }
                        }

                        for (var j = 0; j < Diagram.connectors.length; j++) {
                            wrapper = Diagram.connectors[j].wrapper;

                            for (var k = 0; k < wrapper.children.length; k++) {
                                wrapper.children[k].isExport = isExport;

                                if (isExport) {
                                    wrapper.children[k].exportScaleValue.x = value;
                                    wrapper.children[k].exportScaleValue.y = value;
                                    wrapper.children[k].exportScaleOffset.x = scaleOffsetX;
                                    wrapper.children[k].exportScaleOffset.y = scaleOffsetY;
                                }
                            }
                        }
                    },
                    isImageExportable: function isImageExportable(backgroundImage) {
                        var state = true;
                        var content;
                        var canvas;

                        if (backgroundImage.source) {
                            try {
                                canvas = this.createCanvas(Diagram.id + 'temp_canvas', 100, 100);
                                var ctx = canvas.getContext('2d');
                                ctx.save();
                                var image = new Image();
                                image.src = backgroundImage.source;
                                ctx.drawImage(image, 0, 0, 100, 100);
                                ctx.restore();
                                content = canvas.toDataURL();
                            } catch (e) {
                                state = false;
                            }
                        }

                        return state;
                    },
                    getPrintCanvasStyle: function getPrintCanvasStyle(img, options) {
                        var width = 0;
                        var height = 0;
                        var size = new Size();
                        width = img.width;
                        height = img.height;

                        if (options.pageHeight || options.pageWidth) {
                            height = options.pageHeight ? options.pageHeight : height;
                            width = options.pageWidth ? options.pageWidth : width;
                        }

                        if (options.pageOrientation) {
                            if (options.pageOrientation === 'Landscape' && height > width || options.pageOrientation === 'Portrait' && width > height) {
                                var temp = width;
                                width = height;
                                height = temp;
                            }
                        }

                        size.height = height;
                        size.width = width;
                        return size;
                    },
                    getMultipleImage: function getMultipleImage(img, options, isExport) {
                        var imageArray = [];
                        var div = this.createHtmlElement('div', {});
                        var pageSize = this.getPrintCanvasStyle(img, options); //let pageWidth: number;
                        //let pageHeight: number;

                        var margin = options.margin;
                        var mLeft = margin.left;
                        var mTop = margin.top;
                        var mRight = margin.right;
                        var mBottom = margin.bottom;
                        var x = 0;
                        var y = 0;
                        var pageWidth = pageSize.width + x;
                        var pageHeight = pageSize.height + y;
                        var drawnX = 0;
                        var drawnY = 0;

                        if (options && options.multiplePage) {
                            div.style.height = 'auto';
                            div.style.width = 'auto';
                            var imgHeight = img.height;
                            var imgWidth = img.width; //if (img) {

                            var i = 0;
                            var j = 0;
                            var url = void 0;
                            var clipWidth = 0;
                            var clipHeight = 0;
                            var ctx = void 0;
                            var canvas = void 0;

                            do {
                                do {
                                    clipWidth = pageSize.width;
                                    clipHeight = pageSize.height;

                                    if (drawnX + pageSize.width >= imgWidth) {
                                        clipWidth = imgWidth - drawnX;
                                    }

                                    if (drawnY + pageSize.height >= imgHeight) {
                                        clipHeight = imgHeight - drawnY;
                                    }

                                    canvas = this.createCanvas(Diagram.id + '_multiplePrint', pageSize.width, pageSize.height);
                                    ctx = canvas.getContext('2d');
                                    ctx.drawImage(img, x + drawnX + mLeft, y + drawnY + mTop, clipWidth - mRight - mLeft, clipHeight - mBottom - mTop, 0 + mLeft, 0 + mTop, clipWidth - mRight - mLeft, clipHeight - mBottom - mTop);

                                    if (drawnX + pageSize.width >= imgWidth) {
                                        drawnX -= drawnX - imgWidth;
                                    }

                                    url = canvas.toDataURL();
                                    ctx.restore();
                                    drawnX += pageWidth;

                                    if (isExport) {
                                        imageArray.push(url);
                                    } else {
                                        this.printImage(div, url, i + '' + j, pageWidth + 'px;', pageHeight + 'px;');
                                    }

                                    i++;
                                } while (drawnX < imgWidth);

                                j++;
                                i = x = drawnX = 0;

                                if (drawnY + pageSize.height >= imgHeight) {
                                    drawnY -= drawnY - imgHeight;
                                }

                                drawnY += pageHeight;
                            } while (drawnY < imgHeight); //}

                        } else {
                            var x_1 = 0;
                            var y_1 = 0;
                            var pageSize_1 = this.getPrintCanvasStyle(img, options); ///let pageWidth: number; let pageHeight: number;

                            var pageWidth_1 = pageSize_1.width;
                            var pageHeight_1 = pageSize_1.height; //let ctx: CanvasRenderingContext2D;
                            //let canvas: HTMLCanvasElement;
                            //let url: string;

                            var canvas = this.createCanvas(Diagram.id + '_diagram', pageWidth_1, pageHeight_1);
                            var ctx = canvas.getContext('2d');
                            ctx.drawImage(img, x_1 + mLeft, y_1 + mTop, img.width - (mRight + mLeft), img.height - (mTop + mBottom), 0 + mLeft, 0 + mTop, pageWidth_1 - (mRight + mLeft), pageHeight_1 - (mTop + mBottom));
                            var url = canvas.toDataURL();
                            ctx.restore();

                            if (isExport) {
                                imageArray.push(url);
                            } else {
                                this.printImage(div, url, 0);
                            }
                        }

                        if (isExport) {
                            return imageArray;
                        } else {
                            return div;
                        }
                    },
                    printImage: function printImage(div, url, i, pageWidth, pageHeight) {
                        var attr = {
                            'class': 'e-diagram-print-page',
                            'style': 'width:' + pageWidth + 'height:' + pageHeight
                        };
                        var img = this.createHtmlElement('img', attr);
                        var innerDiv = this.createHtmlElement('div', attr);
                        attr = {
                            'id': Diagram.id + '_multiplePrint_img' + i,
                            'style': 'float:left',
                            'src': url
                        };
                        setAttributeHtml(img, attr);
                        innerDiv.appendChild(img);
                        div.appendChild(innerDiv);
                    },

                    /**
                    * To print the image
                    *
                    * @private
                    */
                    print: function (options, diagram) {
                        return __awaiter(this, void 0, void 0, function () {
                            var url;
                            var _this = this;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        options.mode = 'Data';
                                        Diagram = diagram;
                                        return [4, this.exportDiagram(options, diagram)];
                                    case 1:
                                        url = _a.sent();
                                        if (url instanceof Promise) {
                                            url.then(function (data) {
                                                _this.printImages(data, options);
                                                return data;
                                            });
                                            return [2, url];
                                        }
                                        else {
                                            _this.printImages(url, options);
                                            return [2, url];
                                        }
                                        return [2];
                                }
                            });
                        });
                    },
                    printImages: function printImages(url, options) {
                        var _this = this;

                        var attr = {
                            'id': Diagram.id + '_printImage',
                            'src': url
                        };
                        options.margin = {
                            top: 0,
                            bottom: 0,
                            right: 0,
                            left: 0
                        };
                        var img = this.createHtmlElement('img', attr);

                        img.onload = function () {
                            var div = _this.getMultipleImage(img, options); // specify window parameters


                            var printWind = window.open('');
                            //var elementid = document.getElementById(Diagram.id);
                            if (printWind != null) {
                                if (div instanceof HTMLElement) {
                                    printWind.document.write('<html><head><style> body{margin:0px;}  @media print { .e-diagram-print-page' + '{page-break-after: left; }.e-diagram-print-page:last-child {page-break-after: avoid;}}' + '</style><title></title></head>');
                                    printWind.addEventListener('load', function (event) {
                                        setTimeout(function () {
                                            printWind.window.print();
                                        }, 3000);
                                    });
                                    printWind.document.write('<center>' + div.innerHTML + '</center>');
                                    printWind.document.close();
                                }
                            }
                        };
                    },

                    /** @private */
                    exportImages: function exportImages(image, options) {
                        var _this = this;

                        var region = options && options.region ? options.region : 'Content';
                        var margin = options.margin || {};
                        margin = {
                            top: !isNaN(margin.top) ? margin.top : 0,
                            bottom: !isNaN(margin.bottom) ? margin.bottom : 0,
                            left: !isNaN(margin.left) ? margin.left : 0,
                            right: !isNaN(margin.right) ? margin.right : 0
                        };
                        var bounds = this.getDiagramBounds(region, {});

                        if (options.bounds) {
                            bounds.x = !isNaN(options.bounds.x) ? options.bounds.x : bounds.x;
                            bounds.y = !isNaN(options.bounds.y) ? options.bounds.y : bounds.y;
                            bounds.width = options.bounds.width || bounds.width;
                            bounds.height = options.bounds.height || bounds.height;
                        }

                        var img = document.createElement('img');
                        var attr = {
                            'src': image
                        };
                        setAttributeHtml(img, attr);
                        var context = this;

                        img.onload = function () {
                            var canvas = _this.createCanvas(context.diagram.id + 'innerImage', bounds.width + (margin.left + margin.right), bounds.height + (margin.top + margin.bottom));

                            var ctx = canvas.getContext('2d');
                            ctx.fillStyle = context.diagram.pageSettings.background.color;
                            ctx.fillRect(0, 0, bounds.width + (margin.left + margin.right), bounds.height + (margin.top + margin.bottom));
                            ctx.drawImage(img, 0, 0, bounds.width, bounds.height, margin.left, margin.top, bounds.width, bounds.height);
                            image = canvas.toDataURL();

                            if (options.printOptions) {
                                context.printImages(image, options);
                                return;
                            }

                            ctx.restore();
                            var fileName = options.fileName || 'diagram';

                            _this.canvasMultiplePage(options, canvas, margin, image, fileName);
                        };
                    }
                };
                return diagram;
            }();

            /***/
        })

    /******/
});